use crate::scanner::lexemes::{LexemeSet, LexemeIterator};

#[derive(Clone, Copy)]
#[repr(u32)]
pub enum CLexemes {
    Identifier,
    IntegerConst,
    FloatConst,
    OctalCharConst,
    CharConst,
    StringConst,
    LBracket,
    RBracket,
    LParen,
    RParen,
    LBrace,
    RBrace,
    Dot,
    Arrow,
    Increment,
    Decrement,
    BitAnd,
    Star,
    Plus,
    Minus,
    Tilde,
    Bang,
    Slash,
    Percent,
    LShift,
    RShift,
    Lt,
    Gt,
    Leq,
    Geq,
    Eq,
    Neq,
    Xor,
    BitOr,
    And,
    Or,
    Question,
    Colon,
    Semicolon,
    Ellipsis,
    Assign,
    MultAssign,
    DivAssign,
    ModAssign,
    AddAssign,
    SubAssign,
    LShiftAssign,
    RShiftAssign,
    AndAssign,
    XorAssign,
    OrAssign,
    Comma,
    Comment,
    MultilineComment,
    Whitespace,
    Hash,
    HeaderName,
}

impl LexemeSet for CLexemes {
    fn from_name(name: &str) -> Self {
        match name {
            "Identifier" => CLexemes::Identifier,
            "IntegerConst" => CLexemes::IntegerConst,
            "FloatConst" => CLexemes::FloatConst,
            "OctalCharConst" => CLexemes::OctalCharConst,
            "CharConst" => CLexemes::CharConst,
            "StringConst" => CLexemes::StringConst,
            "LBracket" => CLexemes::LBracket,
            "RBracket" => CLexemes::RBracket,
            "LParen" => CLexemes::LParen,
            "RParen" => CLexemes::RParen,
            "LBrace" => CLexemes::LBrace,
            "RBrace" => CLexemes::RBrace,
            "Dot" => CLexemes::Dot,
            "Arrow" => CLexemes::Arrow,
            "Increment" => CLexemes::Increment,
            "Decrement" => CLexemes::Decrement,
            "BitAnd" => CLexemes::BitAnd,
            "Star" => CLexemes::Star,
            "Plus" => CLexemes::Plus,
            "Minus" => CLexemes::Minus,
            "Tilde" => CLexemes::Tilde,
            "Bang" => CLexemes::Bang,
            "Slash" => CLexemes::Slash,
            "Percent" => CLexemes::Percent,
            "LShift" => CLexemes::LShift,
            "RShift" => CLexemes::RShift,
            "Lt" => CLexemes::Lt,
            "Gt" => CLexemes::Gt,
            "Leq" => CLexemes::Leq,
            "Geq" => CLexemes::Geq,
            "Eq" => CLexemes::Eq,
            "Neq" => CLexemes::Neq,
            "Xor" => CLexemes::Xor,
            "BitOr" => CLexemes::BitOr,
            "And" => CLexemes::And,
            "Or" => CLexemes::Or,
            "Question" => CLexemes::Question,
            "Colon" => CLexemes::Colon,
            "Semicolon" => CLexemes::Semicolon,
            "Ellipsis" => CLexemes::Ellipsis,
            "Assign" => CLexemes::Assign,
            "MultAssign" => CLexemes::MultAssign,
            "DivAssign" => CLexemes::DivAssign,
            "ModAssign" => CLexemes::ModAssign,
            "AddAssign" => CLexemes::AddAssign,
            "SubAssign" => CLexemes::SubAssign,
            "LShiftAssign" => CLexemes::LShiftAssign,
            "RShiftAssign" => CLexemes::RShiftAssign,
            "AndAssign" => CLexemes::AndAssign,
            "XorAssign" => CLexemes::XorAssign,
            "OrAssign" => CLexemes::OrAssign,
            "Comma" => CLexemes::Comma,
            "Comment" => CLexemes::Comment,
            "MultilineComment" => CLexemes::MultilineComment,
            "Whitespace" => CLexemes::Whitespace,
            "Hash" => CLexemes::Hash,
            "HeaderName" => CLexemes::HeaderName,
            _ => panic!("unrecognized variant")
        }
    }

    fn from_id(id: u32) -> Self {
        unsafe { std::mem::transmute::<u32, Self>(id) }
    }

    fn to_name(self) -> &'static str {
        match self {
            CLexemes::Identifier => "Identifier",
            CLexemes::IntegerConst => "IntegerConst",
            CLexemes::FloatConst => "FloatConst",
            CLexemes::OctalCharConst => "OctalCharConst",
            CLexemes::CharConst => "CharConst",
            CLexemes::StringConst => "StringConst",
            CLexemes::LBracket => "LBracket",
            CLexemes::RBracket => "RBracket",
            CLexemes::LParen => "LParen",
            CLexemes::RParen => "RParen",
            CLexemes::LBrace => "LBrace",
            CLexemes::RBrace => "RBrace",
            CLexemes::Dot => "Dot",
            CLexemes::Arrow => "Arrow",
            CLexemes::Increment => "Increment",
            CLexemes::Decrement => "Decrement",
            CLexemes::BitAnd => "BitAnd",
            CLexemes::Star => "Star",
            CLexemes::Plus => "Plus",
            CLexemes::Minus => "Minus",
            CLexemes::Tilde => "Tilde",
            CLexemes::Bang => "Bang",
            CLexemes::Slash => "Slash",
            CLexemes::Percent => "Percent",
            CLexemes::LShift => "LShift",
            CLexemes::RShift => "RShift",
            CLexemes::Lt => "Lt",
            CLexemes::Gt => "Gt",
            CLexemes::Leq => "Leq",
            CLexemes::Geq => "Geq",
            CLexemes::Eq => "Eq",
            CLexemes::Neq => "Neq",
            CLexemes::Xor => "Xor",
            CLexemes::BitOr => "BitOr",
            CLexemes::And => "And",
            CLexemes::Or => "Or",
            CLexemes::Question => "Question",
            CLexemes::Colon => "Colon",
            CLexemes::Semicolon => "Semicolon",
            CLexemes::Ellipsis => "Ellipsis",
            CLexemes::Assign => "Assign",
            CLexemes::MultAssign => "MultAssign",
            CLexemes::DivAssign => "DivAssign",
            CLexemes::ModAssign => "ModAssign",
            CLexemes::AddAssign => "AddAssign",
            CLexemes::SubAssign => "SubAssign",
            CLexemes::LShiftAssign => "LShiftAssign",
            CLexemes::RShiftAssign => "RShiftAssign",
            CLexemes::AndAssign => "AndAssign",
            CLexemes::XorAssign => "XorAssign",
            CLexemes::OrAssign => "OrAssign",
            CLexemes::Comma => "Comma",
            CLexemes::Comment => "Comment",
            CLexemes::MultilineComment => "MultilineComment",
            CLexemes::Whitespace => "Whitespace",
            CLexemes::Hash => "Hash",
            CLexemes::HeaderName => "HeaderName",
        }
    }

    fn to_id(self) -> u32 {
        self as u32
    }

    fn pattern(self) -> &'static str {
        match self {
            CLexemes::Identifier => "[_a-zA-Z][_a-zA-Z0-9]*",
            CLexemes::IntegerConst => "[1-9][0-9]*|(0x|0X)[0-9a-fA-F]+",
            CLexemes::FloatConst => "[\\-+]?([0-9]*\\.)?[0-9]+([eE][\\-+]?[0-9]+)?",
            CLexemes::OctalCharConst => "\\\\[0-7]{1,3}",
            CLexemes::CharConst => "\'.\'",
            CLexemes::StringConst => "\"[^\"]*\"",
            CLexemes::LBracket => "\\[",
            CLexemes::RBracket => "\\]",
            CLexemes::LParen => "\\(",
            CLexemes::RParen => "\\)",
            CLexemes::LBrace => "\\{",
            CLexemes::RBrace => "\\}",
            CLexemes::Dot => "\\.",
            CLexemes::Arrow => "->",
            CLexemes::Increment => "\\+\\+",
            CLexemes::Decrement => "--",
            CLexemes::BitAnd => "&",
            CLexemes::Star => "\\*",
            CLexemes::Plus => "\\+",
            CLexemes::Minus => "-",
            CLexemes::Tilde => "~",
            CLexemes::Bang => "!",
            CLexemes::Slash => "/",
            CLexemes::Percent => "%",
            CLexemes::LShift => "<<",
            CLexemes::RShift => ">>",
            CLexemes::Lt => "<",
            CLexemes::Gt => ">",
            CLexemes::Leq => "<=",
            CLexemes::Geq => ">=",
            CLexemes::Eq => "==",
            CLexemes::Neq => "!=",
            CLexemes::Xor => "^",
            CLexemes::BitOr => "\\|",
            CLexemes::And => "&&",
            CLexemes::Or => "\\|\\|",
            CLexemes::Question => "?",
            CLexemes::Colon => ":",
            CLexemes::Semicolon => ";",
            CLexemes::Ellipsis => "\\.\\.\\.",
            CLexemes::Assign => "=",
            CLexemes::MultAssign => "*=",
            CLexemes::DivAssign => "/=",
            CLexemes::ModAssign => "%=",
            CLexemes::AddAssign => "\\+=",
            CLexemes::SubAssign => "-=",
            CLexemes::LShiftAssign => "<<=",
            CLexemes::RShiftAssign => ">>=",
            CLexemes::AndAssign => "&=",
            CLexemes::XorAssign => "^=",
            CLexemes::OrAssign => "\\|=",
            CLexemes::Comma => ",",
            CLexemes::Comment => "//[^\\n]*\\n",
            CLexemes::MultilineComment => "/\\*([^\\*]|\\*[^/])*\\*/",
            CLexemes::Whitespace => "[ \\t\\n\\v\\f]",
            CLexemes::Hash => "#",
            CLexemes::HeaderName => "<[^\\n>]+>|\"[^\\n\"]\"",
        }
    }

    fn next(self) -> Option<Self> {
        if self.to_id() >= 57 - 1 { None } else { Some(Self::from_id(self.to_id() + 1)) }
    }
}