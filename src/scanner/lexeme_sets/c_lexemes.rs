use crate::scanner::lexemes::{LexemeSet, LexemeIterator};

#[derive(Clone, Copy, PartialEq, Eq, Debug)]
#[repr(u32)]
pub enum CLexemes {
    Auto,
    Break,
    Case,
    Char,
    Const,
    Continue,
    Default,
    Do,
    Double,
    Else,
    Enum,
    Extern,
    Float,
    For,
    Goto,
    If,
    Inline,
    Int,
    Long,
    Register,
    Restrict,
    Return,
    Short,
    Signed,
    Sizeof,
    Static,
    Struct,
    Switch,
    Typedef,
    Union,
    Unsigned,
    Void,
    Volatile,
    While,
    Bool,
    Complex,
    Imaginary,
    Identifier,
    IntegerConst,
    FloatConst,
    OctalCharConst,
    CharConst,
    StringConst,
    LBracket,
    RBracket,
    LParen,
    RParen,
    LBrace,
    RBrace,
    Dot,
    Arrow,
    Increment,
    Decrement,
    BitAnd,
    Star,
    Plus,
    Minus,
    Tilde,
    Bang,
    Slash,
    Percent,
    LShift,
    RShift,
    Lt,
    Gt,
    Leq,
    Geq,
    Eq,
    Neq,
    Xor,
    BitOr,
    And,
    Or,
    Question,
    Colon,
    Semicolon,
    Ellipsis,
    Assign,
    MultAssign,
    DivAssign,
    ModAssign,
    AddAssign,
    SubAssign,
    LShiftAssign,
    RShiftAssign,
    AndAssign,
    XorAssign,
    OrAssign,
    Comma,
    Comment,
    MultilineComment,
    Whitespace,
    Hash,
    HeaderName,
}

impl LexemeSet for CLexemes {
    fn from_name(name: &str) -> Option<Self> {
        match name {
            "Auto" => Some(CLexemes::Auto),
            "Break" => Some(CLexemes::Break),
            "Case" => Some(CLexemes::Case),
            "Char" => Some(CLexemes::Char),
            "Const" => Some(CLexemes::Const),
            "Continue" => Some(CLexemes::Continue),
            "Default" => Some(CLexemes::Default),
            "Do" => Some(CLexemes::Do),
            "Double" => Some(CLexemes::Double),
            "Else" => Some(CLexemes::Else),
            "Enum" => Some(CLexemes::Enum),
            "Extern" => Some(CLexemes::Extern),
            "Float" => Some(CLexemes::Float),
            "For" => Some(CLexemes::For),
            "Goto" => Some(CLexemes::Goto),
            "If" => Some(CLexemes::If),
            "Inline" => Some(CLexemes::Inline),
            "Int" => Some(CLexemes::Int),
            "Long" => Some(CLexemes::Long),
            "Register" => Some(CLexemes::Register),
            "Restrict" => Some(CLexemes::Restrict),
            "Return" => Some(CLexemes::Return),
            "Short" => Some(CLexemes::Short),
            "Signed" => Some(CLexemes::Signed),
            "Sizeof" => Some(CLexemes::Sizeof),
            "Static" => Some(CLexemes::Static),
            "Struct" => Some(CLexemes::Struct),
            "Switch" => Some(CLexemes::Switch),
            "Typedef" => Some(CLexemes::Typedef),
            "Union" => Some(CLexemes::Union),
            "Unsigned" => Some(CLexemes::Unsigned),
            "Void" => Some(CLexemes::Void),
            "Volatile" => Some(CLexemes::Volatile),
            "While" => Some(CLexemes::While),
            "Bool" => Some(CLexemes::Bool),
            "Complex" => Some(CLexemes::Complex),
            "Imaginary" => Some(CLexemes::Imaginary),
            "Identifier" => Some(CLexemes::Identifier),
            "IntegerConst" => Some(CLexemes::IntegerConst),
            "FloatConst" => Some(CLexemes::FloatConst),
            "OctalCharConst" => Some(CLexemes::OctalCharConst),
            "CharConst" => Some(CLexemes::CharConst),
            "StringConst" => Some(CLexemes::StringConst),
            "LBracket" => Some(CLexemes::LBracket),
            "RBracket" => Some(CLexemes::RBracket),
            "LParen" => Some(CLexemes::LParen),
            "RParen" => Some(CLexemes::RParen),
            "LBrace" => Some(CLexemes::LBrace),
            "RBrace" => Some(CLexemes::RBrace),
            "Dot" => Some(CLexemes::Dot),
            "Arrow" => Some(CLexemes::Arrow),
            "Increment" => Some(CLexemes::Increment),
            "Decrement" => Some(CLexemes::Decrement),
            "BitAnd" => Some(CLexemes::BitAnd),
            "Star" => Some(CLexemes::Star),
            "Plus" => Some(CLexemes::Plus),
            "Minus" => Some(CLexemes::Minus),
            "Tilde" => Some(CLexemes::Tilde),
            "Bang" => Some(CLexemes::Bang),
            "Slash" => Some(CLexemes::Slash),
            "Percent" => Some(CLexemes::Percent),
            "LShift" => Some(CLexemes::LShift),
            "RShift" => Some(CLexemes::RShift),
            "Lt" => Some(CLexemes::Lt),
            "Gt" => Some(CLexemes::Gt),
            "Leq" => Some(CLexemes::Leq),
            "Geq" => Some(CLexemes::Geq),
            "Eq" => Some(CLexemes::Eq),
            "Neq" => Some(CLexemes::Neq),
            "Xor" => Some(CLexemes::Xor),
            "BitOr" => Some(CLexemes::BitOr),
            "And" => Some(CLexemes::And),
            "Or" => Some(CLexemes::Or),
            "Question" => Some(CLexemes::Question),
            "Colon" => Some(CLexemes::Colon),
            "Semicolon" => Some(CLexemes::Semicolon),
            "Ellipsis" => Some(CLexemes::Ellipsis),
            "Assign" => Some(CLexemes::Assign),
            "MultAssign" => Some(CLexemes::MultAssign),
            "DivAssign" => Some(CLexemes::DivAssign),
            "ModAssign" => Some(CLexemes::ModAssign),
            "AddAssign" => Some(CLexemes::AddAssign),
            "SubAssign" => Some(CLexemes::SubAssign),
            "LShiftAssign" => Some(CLexemes::LShiftAssign),
            "RShiftAssign" => Some(CLexemes::RShiftAssign),
            "AndAssign" => Some(CLexemes::AndAssign),
            "XorAssign" => Some(CLexemes::XorAssign),
            "OrAssign" => Some(CLexemes::OrAssign),
            "Comma" => Some(CLexemes::Comma),
            "Comment" => Some(CLexemes::Comment),
            "MultilineComment" => Some(CLexemes::MultilineComment),
            "Whitespace" => Some(CLexemes::Whitespace),
            "Hash" => Some(CLexemes::Hash),
            "HeaderName" => Some(CLexemes::HeaderName),
            _ => None
        }
    }

    fn from_id(id: u32) -> Option<Self> {
        if id >= Self::size() { return None; }
        unsafe { Some(std::mem::transmute::<u32, Self>(id)) }
    }

    fn to_name(self) -> &'static str {
        match self {
            CLexemes::Auto => "Auto",
            CLexemes::Break => "Break",
            CLexemes::Case => "Case",
            CLexemes::Char => "Char",
            CLexemes::Const => "Const",
            CLexemes::Continue => "Continue",
            CLexemes::Default => "Default",
            CLexemes::Do => "Do",
            CLexemes::Double => "Double",
            CLexemes::Else => "Else",
            CLexemes::Enum => "Enum",
            CLexemes::Extern => "Extern",
            CLexemes::Float => "Float",
            CLexemes::For => "For",
            CLexemes::Goto => "Goto",
            CLexemes::If => "If",
            CLexemes::Inline => "Inline",
            CLexemes::Int => "Int",
            CLexemes::Long => "Long",
            CLexemes::Register => "Register",
            CLexemes::Restrict => "Restrict",
            CLexemes::Return => "Return",
            CLexemes::Short => "Short",
            CLexemes::Signed => "Signed",
            CLexemes::Sizeof => "Sizeof",
            CLexemes::Static => "Static",
            CLexemes::Struct => "Struct",
            CLexemes::Switch => "Switch",
            CLexemes::Typedef => "Typedef",
            CLexemes::Union => "Union",
            CLexemes::Unsigned => "Unsigned",
            CLexemes::Void => "Void",
            CLexemes::Volatile => "Volatile",
            CLexemes::While => "While",
            CLexemes::Bool => "Bool",
            CLexemes::Complex => "Complex",
            CLexemes::Imaginary => "Imaginary",
            CLexemes::Identifier => "Identifier",
            CLexemes::IntegerConst => "IntegerConst",
            CLexemes::FloatConst => "FloatConst",
            CLexemes::OctalCharConst => "OctalCharConst",
            CLexemes::CharConst => "CharConst",
            CLexemes::StringConst => "StringConst",
            CLexemes::LBracket => "LBracket",
            CLexemes::RBracket => "RBracket",
            CLexemes::LParen => "LParen",
            CLexemes::RParen => "RParen",
            CLexemes::LBrace => "LBrace",
            CLexemes::RBrace => "RBrace",
            CLexemes::Dot => "Dot",
            CLexemes::Arrow => "Arrow",
            CLexemes::Increment => "Increment",
            CLexemes::Decrement => "Decrement",
            CLexemes::BitAnd => "BitAnd",
            CLexemes::Star => "Star",
            CLexemes::Plus => "Plus",
            CLexemes::Minus => "Minus",
            CLexemes::Tilde => "Tilde",
            CLexemes::Bang => "Bang",
            CLexemes::Slash => "Slash",
            CLexemes::Percent => "Percent",
            CLexemes::LShift => "LShift",
            CLexemes::RShift => "RShift",
            CLexemes::Lt => "Lt",
            CLexemes::Gt => "Gt",
            CLexemes::Leq => "Leq",
            CLexemes::Geq => "Geq",
            CLexemes::Eq => "Eq",
            CLexemes::Neq => "Neq",
            CLexemes::Xor => "Xor",
            CLexemes::BitOr => "BitOr",
            CLexemes::And => "And",
            CLexemes::Or => "Or",
            CLexemes::Question => "Question",
            CLexemes::Colon => "Colon",
            CLexemes::Semicolon => "Semicolon",
            CLexemes::Ellipsis => "Ellipsis",
            CLexemes::Assign => "Assign",
            CLexemes::MultAssign => "MultAssign",
            CLexemes::DivAssign => "DivAssign",
            CLexemes::ModAssign => "ModAssign",
            CLexemes::AddAssign => "AddAssign",
            CLexemes::SubAssign => "SubAssign",
            CLexemes::LShiftAssign => "LShiftAssign",
            CLexemes::RShiftAssign => "RShiftAssign",
            CLexemes::AndAssign => "AndAssign",
            CLexemes::XorAssign => "XorAssign",
            CLexemes::OrAssign => "OrAssign",
            CLexemes::Comma => "Comma",
            CLexemes::Comment => "Comment",
            CLexemes::MultilineComment => "MultilineComment",
            CLexemes::Whitespace => "Whitespace",
            CLexemes::Hash => "Hash",
            CLexemes::HeaderName => "HeaderName",
        }
    }

    fn to_id(self) -> u32 {
        self as u32
    }

    fn pattern(self) -> &'static str {
        match self {
            CLexemes::Auto => "auto",
            CLexemes::Break => "break",
            CLexemes::Case => "case",
            CLexemes::Char => "char",
            CLexemes::Const => "const",
            CLexemes::Continue => "continue",
            CLexemes::Default => "default",
            CLexemes::Do => "do",
            CLexemes::Double => "double",
            CLexemes::Else => "else",
            CLexemes::Enum => "enum",
            CLexemes::Extern => "extern",
            CLexemes::Float => "float",
            CLexemes::For => "for",
            CLexemes::Goto => "goto",
            CLexemes::If => "if",
            CLexemes::Inline => "inline",
            CLexemes::Int => "int",
            CLexemes::Long => "long",
            CLexemes::Register => "register",
            CLexemes::Restrict => "restrict",
            CLexemes::Return => "return",
            CLexemes::Short => "short",
            CLexemes::Signed => "signed",
            CLexemes::Sizeof => "sizeof",
            CLexemes::Static => "static",
            CLexemes::Struct => "struct",
            CLexemes::Switch => "switch",
            CLexemes::Typedef => "typedef",
            CLexemes::Union => "union",
            CLexemes::Unsigned => "unsigned",
            CLexemes::Void => "void",
            CLexemes::Volatile => "volatile",
            CLexemes::While => "while",
            CLexemes::Bool => "_Bool",
            CLexemes::Complex => "_Complex",
            CLexemes::Imaginary => "_Imaginary",
            CLexemes::Identifier => "[_a-zA-Z][_a-zA-Z0-9]*",
            CLexemes::IntegerConst => "[1-9][0-9]*|(0x|0X)[0-9a-fA-F]+",
            CLexemes::FloatConst => "[\\-+]?([0-9]*\\.)?[0-9]+([eE][\\-+]?[0-9]+)?",
            CLexemes::OctalCharConst => "\\\\[0-7]{1,3}",
            CLexemes::CharConst => "\'.\'",
            CLexemes::StringConst => "\"[^\"]*\"",
            CLexemes::LBracket => "\\[",
            CLexemes::RBracket => "\\]",
            CLexemes::LParen => "\\(",
            CLexemes::RParen => "\\)",
            CLexemes::LBrace => "\\{",
            CLexemes::RBrace => "\\}",
            CLexemes::Dot => "\\.",
            CLexemes::Arrow => "->",
            CLexemes::Increment => "\\+\\+",
            CLexemes::Decrement => "--",
            CLexemes::BitAnd => "&",
            CLexemes::Star => "\\*",
            CLexemes::Plus => "\\+",
            CLexemes::Minus => "-",
            CLexemes::Tilde => "~",
            CLexemes::Bang => "!",
            CLexemes::Slash => "/",
            CLexemes::Percent => "%",
            CLexemes::LShift => "<<",
            CLexemes::RShift => ">>",
            CLexemes::Lt => "<",
            CLexemes::Gt => ">",
            CLexemes::Leq => "<=",
            CLexemes::Geq => ">=",
            CLexemes::Eq => "==",
            CLexemes::Neq => "!=",
            CLexemes::Xor => "^",
            CLexemes::BitOr => "\\|",
            CLexemes::And => "&&",
            CLexemes::Or => "\\|\\|",
            CLexemes::Question => "?",
            CLexemes::Colon => ":",
            CLexemes::Semicolon => ";",
            CLexemes::Ellipsis => "\\.\\.\\.",
            CLexemes::Assign => "=",
            CLexemes::MultAssign => "*=",
            CLexemes::DivAssign => "/=",
            CLexemes::ModAssign => "%=",
            CLexemes::AddAssign => "\\+=",
            CLexemes::SubAssign => "-=",
            CLexemes::LShiftAssign => "<<=",
            CLexemes::RShiftAssign => ">>=",
            CLexemes::AndAssign => "&=",
            CLexemes::XorAssign => "^=",
            CLexemes::OrAssign => "\\|=",
            CLexemes::Comma => ",",
            CLexemes::Comment => "//[^\\n]*\\n",
            CLexemes::MultilineComment => "/\\*([^\\*]|\\*[^/])*\\*/",
            CLexemes::Whitespace => "[ \\t\\n\\v\\f]",
            CLexemes::Hash => "#",
            CLexemes::HeaderName => "<[^\\n>]+>|\"[^\\n\"]\"",
        }
    }

    fn next(self) -> Option<Self> {
        if self.to_id() >= 94 - 1 { None } else { Self::from_id(self.to_id() + 1) }
    }

    fn size() -> u32 {
        94
    }
}